syntax = "proto3";

package gbcom.capwap;
option go_package = "./capwap";

/// 规范：
/// 1. enum类型必须有Type后缀
/// 2. 消息类型必须有Msg前缀
/// 3. 控制消息通信采用udp协议，客户端5007，server端5008
/// 4. 文件传输通信采用tcp协议，客户端5007，server端5008

/// 关键消息注解：
/// 1. packet: 控制消息，客户端 <-> Server端 UDP通信的消息结构体
/// 2. MsgType：packet消息类别，消息体必须包含子属性，参考snmp协议，有set请求，get请求，trap通知，inform通知，响应消息类型
/// 2.2.1 MsgType.0:响应消息，接收端根据请求端的set、get、inform消息，应答的响应，响应消息时可以修改header.mcode，但不能修改header.Id
/// 2.2.2 MsgType.1:get请求消息
/// 2.2.3 MsgType.2:set请求消息
/// 2.2.4 MsgType.3:trap通知消息，接收端不需要响应
/// 2.2.4 MsgType.4:inform通知消息，接收端需要应答
/// 3. MsgHeader: packet消息头部，描述packet消息具体的消息类型，接收端依据此头部的消息码判断携带的具体消息结构体
/// 3.1 hdr.version: 消息格式定义的版本号，暂不使用; 此字段一旦改变，意味着本消息结构体的定义全部重新定义【verdor，mcode的定义都将发生变化】
/// 3.2 hdr.id: 每台设备发出的请求消息，id唯一【一段时间内】
/// 3.3 hdr.mcode: pcaket携带的具体消息类型
/// 3.4 hdr.ecode-error: 针对响应消息有效，响应消息失败后携带失败的原因码和描述信息

// 消息码厂商，或者厂商自定义模块
enum VendorType {
  Unknownx   = 0;
  Gbcom      = 1;
}

// 消息类型
enum MsgType {
  Response   = 0; // get/set/inform.request response
  GetRequest = 1; // 查询请求，返回响应
  SetRequest = 2; // 设置设置，返回响应, 通常用于server段主动向客户端发消息, 让客户端执行某个动作或者发起tcp连接拉去文件
  Trap       = 3; // 客户端向server端，trap.request, server不需要响应
  Inform     = 4; // 客户端向server端，inform.request, server需要响应
}

// 消息代码,消息中携带的有效消息类型
enum MsgCodeType {
  Invailed       = 0; // 无效消息类型
  Reboot         = 1; // omc对设备设置重启
  Alarm          = 2; // 设备向omc发送告警
  Discover       = 3; // 设备向omc发送发现消息【上线请求】
  OnlineStatus   = 4; // omc向设备发送设置上线状态，客户端回应上线状态
  Keepalive      = 5; // 客户端向server端发送的保活消息
  CfgFilesHash   = 6; // 客户端向server端发送的查询配置标签消息，server端需要给响应
  VersionUpgrade = 7; // OMC向客户端方发送需要执行升级到目标版本，并重启, OMC向客户端发送的消息携带MsgFile
  GetCfgFile     = 8; // 客户端从OMC拉取配置文件[/etc/config/filename] OMC向客户端发送的消息携带MsgFile
  PutCfgFile     = 9; // 客户端向OMC上传配置文件，设备首次上线时必须上传配置文件，OMC上保留备份; OMC向客户端发送的消息携带MsgFile
  HbLteSignal    = 10; // 客户端向OMC每秒发送空口信号质量
  HbWlanSignal   = 11; // 客户端向OMC每秒发送空口信号质量
  HbBoradStatus  = 12; // 客户端向OMC每15秒钟发送资源利用统计消息，端口流量
  HbPerMinute    = 13; // 客户端向OMC每60秒钟发送disk资源利用率
  BoradInfo      = 14; // 设备上线时，主动向OMC上报一次单板信息
}

// 针对查询、设置、inform消息响应结果
enum ErrCodeType {
  Ok           = 0; // 成功
  FileNotExist = 1; // 文件不存在
}

// 请求消息的头部
message MsgHeader {
  int32       version = 1; // 消息协议版本号，暂不是使用;hdr中增加了verdor,消息定义需要改变通过字段修订，version预留为整个消息包全新定义
  uint32      id      = 2; // 消息包ID号【一个设备主动发出的消息包，ID自增、唯一】
  VendorType  vendor  = 3;  // 厂商，不同的厂商对消息码可以重新定义【mcode对应的消息结构体】
  MsgCodeType mcode   = 4;  // 消息码，与消息结构体一一对应
  ErrCodeType ecode   = 5;  // 错误吗，针对请求响应反馈响应的结果
  string      error   = 6;  // 若响应码失败，可能携带失败的原因
  string      mac     = 7;  // 客户端->OMC的消息必须携带此参数，若客户端设备为动态IP地址，必须携带此参数标识消息包归属哪个设备;格式A1:B2:C3:D4:E5:F6
}


// OMC与设备之间通信的数据消息体结构
message Message {
  MsgType            type                 = 1; // 消息类型
  MsgHeader          header               = 2; // 请求消息头部
  MsgAlarm           alarm                = 3; // 告警消息
  MsgDiscover        discover             = 4; // 发现消息
  MsgOnline          onlineStatus         = 5; // omc->设置客户端上线消息，客户端->响应上线消息
  MsgKeepalive       keepalive            = 6; // 客户端向OMC端发送的保活消息
  MsgCfgFiles        cfgFiles             = 7; // 客户端向OMC端发送的查询配置标签消息，OMC端需要给响应; 客户端通过心跳消息主动检查配置同步
  MsgFile            versionUpgrade       = 8; // OMC向客户端方发送需要执行升级到目标版本，并重启; OMC主动发起的强制客户端升级; 正常运维模式不会有此流程
  MsgFile            configUpgrade        = 9; // OMC向客户端方发送需要同步整体配置，并重启; OMC主动泛起的强制客户端整体配置同步; 正常运维模式不会有此流程
  MsgHbLteSignal     hbLteSignal          = 10; // 客户端向OMC每秒发送空口信号质量
  MsgHbWlanSignal    hbWlanSignal         = 11; // 客户端向OMC每秒发送空口信号质量
  MsgHbBoradStatus   hbBoradStatus        = 12; // 客户端向OMC每15秒钟发送资源利用统计消息，端口流量
  MsgHbPerMinute     hbPerMinute          = 13; // 客户端向OMC每60秒钟发送disk资源利用率
  MsgBoradInfo       boradInfo            = 14; // 客户端在上线后，主动向OMC发送一次单板基本信息
}

// 设备上线请求消息【发现消息】,别名是请求上线，客户端以trap消息类型发送，server端不需要响应
message MsgDiscover {
  int32  devCode   = 1; // 设备代码
  string model     = 2; // 设备型号
  string hostname  = 3; // 设备名称
  string sn        = 4; // 设备sn号
  string mac       = 5; // 设备mac
  string ip        = 6; // 设备管理IP
  string version   = 7; // 当前版本
}

// 设备工作状态
enum OnlineStatusType {
  Offline         = 0; // 在网管离线，此状态设备检测到告警信息应该缓存，上线后依次发出
  Online          = 1; // 在网管在线，应周期性发送心跳查询网管是否需要升级和配置同步
  VersionUpdating = 2; // 版本升级中，此状态下心跳还在发送，但心跳中携带的版本和配置信息不在检查更新
  ConfigUpdating  = 3; // 配置同步中，此状态下心跳还在发送，但心跳中携带的版本和配置信息不在检查更新
}

// 设置上线，查询上线状态
message MsgOnline{
  OnlineStatusType  status = 1; // 网管向客户端发送设置上线消息，客户端应答此消息
}

// 告警消息
message MsgAlarm {
  string  sn        = 1; // 告警序列号
  uint32  timestamp = 2; // 告警时间戳，发生时间戳
  int32   code      = 3; // 告警码
  int32   stat      = 4; // 告警类型，0：事件，1：告警产生，2：告警消除
  string  info      = 5; // 告警消息
  string  sign      = 6; // 告警签名，如果inform中标识 Lan4口down， 此处表示为Lan4
}



// 表示配置文件和版本文件;
// 版本文件时hash值无效
message CfgFile {
  string serHash   = 1; // server端存储publish的contant的md5 hash值
  string cliHash   = 2; // server端暂存客户端配置文件内容的hash码
  bool   needSync  = 3; // server端响应客户端是否需要同步此文件
  string name      = 4; // 配置文件别名，包含路径的全名, 例: /etc/config/filename
  bytes  content   = 5; // 配置文件的配置标识，tag值为空则没有此配置
}


// 客户端向服务器发送的心跳消息; OMC向客户端应答该消息
message MsgKeepalive {
  uint32   uptime      = 1; // 系统上电运行工作时长,单位秒
  string   version     = 2; // 设备端正在运行的版本，通过心跳检查及时触发升级
  string   totalHash   = 3; // 客户端所有配置文件按照文件名排序的hash码拼接后重新生成的hash值,标识设备配置唯一
}

// 客户端通过心跳消息判断与server端配置hash不一致，触发查询哪个配置文件不一致，并拉去配置文件更新配置;
// 通过udp接口拉取文件时只包含配置文件名和hash值[客户端用于检查每个配置文件是否与服务端一致], 不包括文件内容[contant];
// 通过tcp接口上传或者拉取文件时,应包含文件内容
message MsgCfgFiles {
  repeated CfgFile files = 1; // 查询哪个文件
}

// Lte信号质量
message LteSinal {
  int32  index    = 1; // LTE模块ID编号
  int32  attached = 2; // 驻网状态
  int32  pcid     = 3; // 接入的PCI
  int32  rsrp     = 4; //
  int32  rsrq     = 5; //
  int32  rssi     = 6; //
  int32  sinr     = 7; //
}

// TAU设备每秒向OMC发送的心跳状态消息
message MsgHbLteSignal {
  repeated LteSinal lteMod = 1; // lte模组信号状态
}

enum PortType{
  Eth       = 0; // 电口以太网
  Sfp       = 1; // 光口以太网
  Lte       = 2; // usb以太网口
  WiFi      = 3; //
  bluetooth = 4; // 蓝牙串口
  console   = 5; // rs232或者rs458串口
}

// 有线口和无线口都用这个端口状态统计
message PortStatistics {
  int32  index    = 1; // 端口index
  int32  type     = 2; // 端口类型
  int32  status   = 3; // 端口状态，0：down，1:10MH,2:10MF,3:100MH,4:100MF,5:1000MH,6:1000MF; H半双工，F全双工
  uint64 rxRate   = 4; // 端口接收速率
  uint64 txRate   = 5; // 端口发送速率
  PortSfpArgs sfp = 6; // 若端口为光口则携带此参数
}

// 对光口的特殊参数定义
message PortSfpArgs{
  int32  index        = 1; // 端口index
  int32  temperature  = 2; // 端口index
  int32  rxPower      = 3; // 接收光功率
  int32  txPower      = 4; // 发射光功率
  int32  txBias       = 5; // 发射偏置电流
  int32  vcc          = 6; // 发射器供电电压

}

message Usage {
  int32 index     = 1; // 对CPUx，DISKx,每个字对象的利用率
  int32 usage     = 2; // 利用率 1-100
}

message Borad {
  int32 index     = 1; // 设备单板号，每个单板是一个独立的系统
  int32 CpuUsage  = 2; // 单个cpu的利用率不做统计，这个是总的利用率
  int32 MemUsage  = 3; // 内存利用率
  repeated Usage diskUsages   = 4; // 多个分区，每个分区的利用率，按照index排序
  repeated PortStatistics portStatistics = 5; // 单板上端口速率统计
}

// 设备每15向OMC发送的心跳状态消息
message MsgHbBoradStatus {
  repeated Borad borads = 1; // 设备有多个单板，每个单板状态
}

// 设备每分钟上报的状态消息
message MsgHbPerMinute {

}

// LTE模组基本信息
message LteModule {
  int32  index     = 1; //
  string model     = 2;
  string version   = 3;
  string imei      = 4;
  string imsi      = 5;
}

// 单板的基本信息
message MsgBoradInfo{
  int32  index     = 1; // 单板编号
  int32  model     = 2; // 设备型号编码
  string sn        = 3; // 主板sn
  string desc      = 4; // 单板描述信息，硬件版本号等
  string bootVer   = 5; // boot版本号
  string kernelVer = 6; // kernel版本号
  string FirmVer   = 7; // firmware，与discover消息中携带的设备当前运行版本一致
  repeated LteModule lteMods = 8; // 单板上携带的LTE模组信息
}

// sta接入AP的状态【sta看到ap】，AP接入sta的状态【ap看到sta】
message WlanLinkStatus {
  int32  modIndex     = 1; // 模块序号
  int32  vapIndex     = 2; // vap序号
  int32  attached     = 3; // 针对STA有效，关联AP的状态；
  int32  rsrp         = 4; // 信号强度,rssi
  int32  noise        = 5; // 噪声强度
  string rxRate       = 6; // 协商速率,获取的值有参数，需要字符串类型
  string txRate       = 7; // 协商速率,获取的值有参数
  string mac          = 8; // sta看到AP的essid-mac，AP看到sta的mac
  string ssid         = 9; // ap广播的ssid名称，sta接入的apssid名称
  int32  deriection   = 10; // 车辆行驶方向的头端、尾端，针对STA有效
}

// WLAN信号每秒上报,【AP只有用户接入时才上报】
message MsgHbWlanSignal {
  bool  isApOrSta     = 1; // 是AP[true]设备还是STA[fals]
  repeated WlanLinkStatus linkStatus = 2; // sta上报是只有一个
}

// WiFi模块基本参数
message WlanModuleArgs {
  int32  index       = 1;
  string mode        = 2; // 工作模式， 11ag，11an， 11ac， 11ax
  string cfgChannel  = 3; // 配置自动信号还是固定信道【固定则是固定的信道号】
  string curChannel  = 4; // 当前工作信道
  string bandwidth   = 5; // 工作频宽
  string txpower     = 6; // 模块当前最大射频功率【配置的功率】
}

// WiFi SSI配置信息
message WlanSsidAargs {
  int32  modIndex = 1; // ssid配置归属模组的编号
  int32  index    = 2; // ssid配置在模组上属于第几个
  int32  workMode = 3; // 工作模式，0：ap，1：sta，2：wds
  string encrType = 4; // 加密方式
  string encrFunc = 5; // 加密算法
  string encrPass = 6; // 加密秘钥
}

// 传输文件的类型
enum FileType {
  Unknown      = 0; // 未知文件类型
  Log          = 1; // 日志文件，OMC向客户端发起上传指定时间内的日志文件
  Pcap         = 2; // 抓包文件，OMC向客户端发起上传指定时间内的通信报文文件
  Version      = 3; // 设备向OMC发起下载版本文件
  ConfigTar    = 4; // 设备向OMC发起下载配置文件,tar包，总配置
  ConfigText   = 5; // 设备向OMC发起下载单个的配置文件【etc/config目录下的文件】
}

// 传输文件请求和响应消息体，传输文件采用tcp流;
// 服务端的版本文件,客户端的日志和抓包文件
message MsgFile {
  FileType type         = 1; // 文件类型
  string   name         = 2; // 文件名称； 若是OMC向设备发送上传日志文件，则是客户端压缩后的文件名称
  string   nameWithPath = 3; // 带有路径的文件名称，OMC向客户端发起上传文件时，带有此参数，客户端上传到指定的路径文件
  int64    startTime    = 4; // 针对log&pcap,目标时间段开始
  int64    endTime      = 5; // 针对log&pcap,目标时间段结束
  bytes    content      = 7; // 文件二进制数据
  int32    cmd          = 8; // 针对文件为ConfigText类型有效，配置文件按照命令执行，还是copy覆盖
}

// 文件传输服务接口
service FileTransport {
  rpc GetFile(Message) returns (MsgFile){}; // 请求下载文件；客户端从OMC下载版本、配置；OMC从客户端下载是通过udp接口向客户端发送上传消息；
  rpc PutFile(MsgFile) returns (Message){}; // 客户端向omc上传文件
}
